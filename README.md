# Comparative-analysis
Сравнительный анализ подходов к организации взаимодействия в приложении

# Motivation
Я пишу эту статью для своего доклада и для того, чтобы самому поглубже погрузиться в архитектуру приложений

# About
In this article, I will touch on several options for organizing the interaction of various parts of our application - these are callback functions (callbacks), generators (yeild) and the message exchange bus (eventemitter).

В этой статье я затрону несколько вариантов организации взаимодействия различных частей frontend приложений — это callback-функции (callbacks), генераторы (yield) и шина обмена сообщениями (eventemitter).

# How it works

Я попытаюсь сравнить эти три метода обработки цепочки синхронных/асинхронных событий по следующим критериям и на основе этих критериев определить для каждого, какую область применения он имеет - то есть какие задачи с его помощью удобнее или более эффективные, а какие нет.

![](https://github.com/aleksandrtamrazov/Comparative-analysis/blob/master/img/mainTable.png)

Каждый ответ будет иметь небольшой пример кода JS, демонстрирующий указанное поведение. Ответ по каждому критерию может содержать два варианта (callback могут использоваться для организации как синхронного, так и асинхронного взаимодействия), в этом случае следует рассматривать оба варианта.

# Main

### Callback

Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.

Коллбэк простая констукция в программировании и она выполняет довольно много полезных действий. Основным плюсом использовать callback-функции - это способ расширения функционала, элемент проектирования функций. Однако callback-функции бывают как синхронные, так и ассинхронные. И тут у них большая разница. ..... (дописать тут немного)

#### callback/sync
Синхронные callback-функции нужны для функциональной композиций. Композиция функций - способ сделать из нескольких фукций одну функцию. Ярким примером является функция pipe, которая используется очень часто. 

Пример функции pipe

```js
const reverse = (string) => string.split('').reverse().join('') // Пример синхронной callback-функции

const uppercase = (string) => strign.toUpperCase(string)

const pipe = (...fns) => (x) => fns.reduсe((v, f) => f(v), x) // пример замыкания
```

Функция pipe принимает callback функции, агрегирует их и на каждую букву в строке вызывает функции.

С помощью такого подхода эффективно решать многие синхронные задачи. Pipe применятся 

#### callback/async

Ассинхнронные операции выполняются callback функциями для того чтобы вернуть значение из функции. Вместо того, чтобы сразу же вернуть какой-то результат, как делает большинство функций, эти использующие обратные вызовы функции требуют время для получения результата.

Этот подход нужен для выполнения ассинхронных операции, таких как работа с файловой системой и запросов на сервер. Например вы хотите сначала прочитать файл с файловой системы, а затем выполнить код функции, но как наверняка узнать когда закончить чтение файла? Ответ: никак) наша функция должна исполниться сразу же после асинхронной операции чтения. Например у нас есть функция readFile, которая читает файл с диск. Далее мы хотим чтобы в консоле после чтения файла появилось сообщение об успехе или не успехе.

```js
readFile('~/Desktop/myFile.txt', log)

function log(err) {
  if(err) {
    console.error('Ошибка чтения!')
  } else {
    console.log('Файл успешно прочитан!')
  }
}

console.log('Операция чтения начата!')
```
Попробуйте ответить сами: какой сообщение мы увидим в консоли раньше?

Такой подход к написанию кода на JavaScript пораждает некоторые проблемы, такие как callback-hell. Решение нашлось в Promise, а далее и в async/await. Не буду подробно останавливаться на этом. Но callback, Promise, async/await используются в js-коде очень часто, и причем повсеместно. Любой разработчик должен их понимать.

Рассказать как работает Event loop

Event loop - это способ о

```js

const callback = () => console.log('I`m from async callback');

setTimeout(callback, 2000);

console.log('I`m from sync code')

// I`m from sync code
// I`m from async callback

```

Код не блокирует цикл событий поэтому

Но если много-чего, то настанет callback-hell

Такой способ реализаций ассинхронных событий устарел после появления Promise

#### callback/stateful

Подход statefull в JavaScript говорит о том, что функция которую мы создаем использует внешнее состояние которое мы инициальзировали выше. А именно она изменяет наше состояние.

```js
const state = 1;

const increment = () => {
  return state += 1;
}

increment(); // 2
```

Такой подход в конструировании функций очень наглядно видно при работе с замыканием.

```js
const getMessage = (msg) => {
  const result = msg;

  return function() {
    return result;
  }
}

var logMessage = getMessage('Hello');
console.log(logMessage()); // Hello
```

#### callback/stateless

Подход stateless в JavaScript говорит о том, что функция которую мы создаем не использует внешнее состояние которое мы инициальзировали выше.

```js
const state = 1;

const decrement = (num) => {
  return num += 1;
}

decrement(state); // 2
```

#### callback/pull
Концепция pull/push систем основывается на паттерне Producer/Consumer. 
Довольно широко эти подходы используются в рективном программировании. RxJs
Эти два подхода описывают как производитель данных (Producer) может взаимодействовать с потребителем данных (Consumer)

Pull системы - это системы в которых Consumer сам определяет как и в какой момент использовать данные, Producer не знает куда и когда будут доставлены данные
Каждая функция JS - это pull система. Функция является источником данных, а код который ее вызывает, является потребителем данных извлекая(pulling) единственно возвращаемое значение из этой функции.

Есть также функции итераторы и генераторы(function*), которые также являются pull системами. [pull and push](http://reactivex.io/rxjs/manual/overview.html)

```js
const producer = () => ({ name: 'Alex', age: 24 })
const consumer = () => { let state = producer() }
```

#### callback/push

Что такое Пуш? В системах Push Производитель определяет, когда отправлять данные Потребителю. Потребитель не знает, когда он получит эти данные.

Промисы — наиболее распространенный тип системы Push в JavaScript на сегодняшний день. Промис (Производитель) предоставляет разрешенное значение зарегистрированным обратным вызовам (Потребителям), но, в отличие от функций, именно Промис отвечает за точное определение того, когда это значение «проталкивается» в обратные вызовы.

```js
let producer = () => new Promise((resolve, reject) => {
  let count = 0;
  setInterval(() => {
    resolve(count++);
  }, 1000);
});

let consumer = data => { console.log(data); };

producer().then(consumer) // 0
```

# Contributing
The main purpose of this repository is to continue evolving me and you. I'll accept any help. You are welcome!
