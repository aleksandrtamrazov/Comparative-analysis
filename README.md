# Сравнительный анализ подходов к организации взаимодействия в приложении
В статье будут затронуты несколько вариантов организации взаимодействия различных частей frontend приложений — это callback-функции (callbacks), генераторы (yield) и шина обмена сообщениями (eventemitter). Три метода обработки цепочки синхронных/асинхронных событий по следующим критериям и на основе этих критериев определить для каждого, какую область применения он имеет - то есть какие задачи с его помощью удобнее или более эффективные, а какие нет. Каждый ответ будет иметь небольшой пример кода JS, демонстрирующий указанное поведение. Ответ по каждому критерию может содержать два варианта (callback могут использоваться для организации как синхронного, так и асинхронного взаимодействия), в этом случае следует рассматривать оба варианта.

### Callback
Основным плюсом использовать callback-функции - это способ расширения функционала, элемент проектирования функций. Однако callback-функции как и обычные функции бывают как синхронные, так и ассинхронные. Синхронные callback-функции нужны для функциональной композиций. Ярким примером является функция pipe, которая используется очень часто.
```js
const reverse = (string) => string.split('').reverse().join('') // Пример синхронной callback-функции

const uppercase = (string) => strign.toUpperCase(string)

const pipe = (...fns) => (x) => fns.reduсe((v, f) => f(v), x)
```
С помощью такого подхода эффективно решать многие синхронные задачи. Ассинхнронные же операции выполняются callback функциями для того чтобы вернуть значение из функции. Вместо того, чтобы сразу же вернуть какой-то результат, как делает большинство функций, эти использующие обратные вызовы функции требуют время для получения результата. Этот подход нужен для выполнения ассинхронных операции, таких как работа с файловой системой и запросов на сервер.
Например, вы хотите сначала прочитать файл с файловой системы, а затем выполнить код функции, но как наверняка узнать когда закончить чтение файла? Ответ: никак, наша функция должна исполниться сразу же после асинхронной операции чтения.
У нас есть функция readFile, которая читает файл с диск. Далее мы хотим чтобы в консоле после чтения файла появилось сообщение об успехе или не успехе.

```js
readFile('~/Desktop/myFile.txt', log)

function log(err) {
  if(err) {
    console.error('Ошибка чтения!')
  } else {
    console.log('Файл успешно прочитан!')
  }
}

console.log('Операция чтения начата!')
```
Попробуйте ответить сами: какой сообщение мы увидим в консоли раньше?
Такой подход к написанию кода на JavaScript пораждает некоторые проблемы, такие как callback-hell. Решение нашлось в Promise, а далее и в async/await. Не буду подробно останавливаться на этом. Но callback, Promise, async/await используются в js-коде очень часто, и причем повсеместно.
Очень важно упомянуть здесь про statefull/stateless. Подход statefull в JavaScript говорит о том, что функция которую мы создаем **использует** внешнее состояние которое мы инициальзировали выше. А именно она изменяет наше состояние. Подход stateless обратный - функция которую мы создаем **не использует** внешнее состояние которое мы инициальзировали выше.

```js
const state = 1;

const increment = () => {
  return state += 1;
}

increment(); // 2
```

```js
const state = 1;

const decrement = (num) => {
  return num += 1;
}

decrement(state); // 2
```
Попробуем разобрать middleware redux-thunk, как структуру построенную на callback-функциях, которая помогает нам исполнять ассинхронные запросы в react-redux приложениях с архитектурой flux. Вот исходный код функции:

```js
function createThunkMiddleware(extraArgument) {
  const middleware =
    ({ dispatch, getState }) =>
    next =>
    action => {
      if (typeof action === 'function') {
        return action(dispatch, getState, extraArgument)
      }

      return next(action)
    }
  return middleware
}
```

Итак, сама по себе библиотека redux-thunk небольшая, главная функция createThunkMiddleware умещается в 17 строк. В ней совмешается подходы синхронного коллбека ввиде принимаемого диспатч, далее есть подход stateless, так как функция не использует никакое внешннее состояние, а также pull-подход(про pull/push немного позже) так как, сама выбирает в какой момент использовать данные.

### Yield (Генераторы)

функции-генераторы

Генераторы очень странная и загадочная часть языка JS. Некоторые разработчики видят их сложными. Вы можете быть успешным разработчиком и никогда не чувстовать необходимости в их использовании. Тогда зачем же они нужны? Попробую ответить на этот вопрос. Генераторы низкоуровневая констукция, они как будто инструменты для создания инструментов, которые решают наши повседневные проблемы, но если смотреть на них изолированно, может показаться что они вообще не нужны. Однако это не так.

Генераторы можно использовать для ленивых итераций. Если вы знакомы с протоколом "Перебора", этот функционал появлся в 2015 году, тогда вы знаете что они тоже относятся к низкоуровневым констукциям. Эти протоколы говорят движку JS, что данный обект можно итерировать или использовать spread оператор для него. 

```js
function* culturalAchievements() {
  yield 'Amazing professional people';
  yield 'The lovely office';
  yield 'Friendly atmosphere';
}

for (achievement of culturalAchievements()) {
    console.log(`Axenix is known for: ${achievement}`);
}
```

Далее давайте расмотрим такую ситуацию, например, ....

```js
const array = [1, 2, 3, 4, 5]


```

такой подход к проетированию функции-генератора называется паттерн трансдюсер

Я не буду вдоваться в подробности генераторов, они могут быть очень полезны, с их помощью можно переписать множется функций высшего порядка таких как map flatMap filter pop pipe 

Попробуем переписать функцию filter из примера коллбеков и посмотрим на разницу подходов

```js
function* filter(predicate, array) {
  for (value of array) {
    if (predicate(value)) {
      yield value
    }
  }
}

console.log(...filter()) // Поскольку функции генераторы возвращает итераторы, то используя оператор spread мы получим нужный нам массив
```

Так например, стейт менеджер redux-saga, использует для выполнения ассинхроных операций функции-генератора.

Код который может выглядеть так

```js
fetchProducts(url).then((val) => {
  console.log(val)
})
```
будет выглядеть так

```js
let value = fetchProducts(url)
console.log(value)
```

Это очень удобно, и делает код визуально синхронным, как и async/await

вот код из под капота redux saga 

```js
function next(arg, isErr) {
  try {
    let result
    if (isErr) {
      result = iterator.throw(arg)
      // user handled the error, we can clear bookkept values
      sagaError.clear()
    } else if (shouldCancel(arg)) {
      /**
        getting TASK_CANCEL automatically cancels the main task
        We can get this value here
        - By cancelling the parent task manually
        - By joining a Cancelled task
      **/
      mainTask.status = CANCELLED
      /**
        Cancels the current effect; this will propagate the cancellation down to any called tasks
      **/
      next.cancel()
      /**
        If this Generator has a `return` method then invokes it
        This will jump to the finally block
      **/
      result = is.func(iterator.return) ? iterator.return(TASK_CANCEL) : { done: true, value: TASK_CANCEL }
    } else if (shouldTerminate(arg)) {
      // We get TERMINATE flag, i.e. by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)
      result = is.func(iterator.return) ? iterator.return() : { done: true }
    } else {
      result = iterator.next(arg)
    }

    if (!result.done) {
      digestEffect(result.value, parentEffectId, next)
    } else {
      /**
        This Generator has ended, terminate the main task and notify the fork queue
      **/
      if (mainTask.status !== CANCELLED) {
        mainTask.status = DONE
      }
      mainTask.cont(result.value)
    }
  } catch (error) {
    if (mainTask.status === CANCELLED) {
      throw error
    }
    mainTask.status = ABORTED

    mainTask.cont(error, true)
  }
}
```

например redux-saga 
Сейчас я немного уйду в сторону попытаюсь обяснить что какие преимущества дает redux saga, но надо помнить что все эти преимущества обоснованы функциями-генераторами. В очередной раз убеждаясь в том что они есть интерументы для интрументов.

1. DOM: jQuery императивный / React декларативный
2. Monads: IO императивный / Free декларативный (еще одна констукция функционального программирвоания, рекомендую почитать)
3. Redux effects: redux-thunk императивный / redux-saga декларативный
### EventEmitter

Концепция pull/push систем основываются на паттерне Producer/Consumer. Довольно широко эти подходы используются в рективном программировании. Эти два подхода описывают как производитель данных (Producer) может взаимодействовать с потребителем данных (Consumer).

Pull системы - это системы в которых Consumer сам определяет как и в какой момент использовать данные, Producer не знает куда и когда будут доставлены данные. Каждая функция JS - это pull система. Функция является источником данных, а код который ее вызывает, является потребителем данных извлекая(pulling) единственно возвращаемое значение из этой функции.

Функции, которые я описывал выше, итераторы и генераторы(function*), также являются pull системами.[pull and push](http://reactivex.io/rxjs/manual/overview.html)

```js
const producer = () => ({ name: 'Alex', age: 24 })
const consumer = () => { let state = producer() }
```

В системах Push Производитель определяет, когда отправлять данные Потребителю. Потребитель не знает, когда он получит эти данные. Промисы — наиболее распространенный тип системы Push в JavaScript на сегодняшний день. Промис (Производитель) предоставляет разрешенное значение зарегистрированным обратным вызовам (Потребителям), но, в отличие от функций, именно Промис отвечает за точное определение того, когда это значение «проталкивается» в обратные вызовы.

```js
let producer = () => new Promise((resolve, reject) => {
  let count = 0;
  setInterval(() => {
    resolve(count++);
  }, 1000);
});

let consumer = data => { console.log(data); };

producer().then(consumer) // 0
```

Итак, на последок попробую рассказать про еще один подход в проектировании систем. Это EventEmitter - это шаблон проектирования. О нем достаточно много написано, и это подход используется в реактивном программировании фреймворк RxJS. Однако я попробую разобрать его. Как я писал выше, pull/push системы довольно частые конструкции в JavaScript. Концепция библиотеки React использует подход pull архитектуры. Это означает что когда React нужно вызвать функцию render, это вызовет рендер всех дочернир компонентов реакта. Это вернет новое предсталение которое потом реакт согласовывать с помощью React.reconcilation. Далее измениния будут преминены на DOM. В этом и состоит pull концепция, в данном случае React, потому что именно он запрашивает новое состояние.

Однако, можно воспользоваться push архитектурой, для того чтобы подписывать компоненты на состояние. Этот подход позволит не только увеличить производительность, но и сделает управление состоянием более декларативным, чтобы можно было читать состояния сверху вниз.


# Contributing
The main purpose of this repository is to continue evolving me and you. I'll accept any help. You are welcome!
